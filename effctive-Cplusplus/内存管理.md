# 内存管理
## 以对象管理资源
### 为什么不以函数管理资源
```C++
void f(){
    Investment* pt1 = createInvestment();
    // 若干代码
    delete pt1;
}
```
随着软件维护的进行，可能会在delete行为之前插入return语句，或者是函数执行到一半发生了异常被捕获跳出该函数。此时，资源就无法被正确释放。因此，我们考虑以对象来管理资源。
### 以对象管理资源的两个重要想法
1. 获得资源后立刻放进管理对象(managing object)
2. 管理对象中利用析构函数确保资源被正确释放
### 有几种管理资源的对象:
+ auto_ptr
auto_ptr被删除时自动销毁其指向的资源，但是他所指向的对象，不能被其他指针所指。考虑一下代码
```C++
    auto_ptr<Investment> ptr1 = createeInvestment();
    auto_ptr<Investment> ptr2;
    ptr2 = ptr1;// 此时ptr1被置为指向NULL
```
若通过copy构造函数或copy assignment操作符复制该指针，指针就被指向null,而复制的指针将指向该资源。
因此auto_ptr永远处于"一对一"的状态。
而STL中容器要求其元素拥有复制行为，因此auto_ptr不适用于STL。

+ shared_ptr(属于RCSPs一类)
shared_ptr则允许所指向的对象被其他指针所指，并且shared_ptr对象内部有一个引用计数器，每次所指向的对象被指向时或者被销毁时，该计数器都会加一或者减一。直到当该计数器为0时，shared_ptr才真正地释放资源。这种行为被成为垃圾回收机制(garbage collection).
```C++
    shared_ptr<Investment> ptr1 = createeInvestment();
    shared_ptr<Investment> ptr2;
    ptr2 = ptr1;// 此时ptr1与ptr2指向同一个对象
```
但是shared_ptr在发生环状引用(两个无用的对象互指)行为时，资源将无法正确释放。
### auto_ptr和shared_ptr的缺点
auto_ptr和shared_ptr在其析构函数中使用的是delete操作而不是delete[]操作。因此auto_ptr和shared_ptr不能被用来指向动态分配的数组。
但是，如果你尝试指向数组，编译器并不会报错。如果使用这两类指针管理数组，数组的资源在该被完全释放时不能够被正确释放，将会使内存泄漏。(参考C++ OOP笔记中delete[] 和delete 的区别)
```C++
    std::shared_ptr<int> ptr(new int[10]);//造成内存泄漏
```
在C++中，数组一般使用STL中的容器，不建议使用原生数组。
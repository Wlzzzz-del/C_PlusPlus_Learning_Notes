# 条款26：尽可能延后变量定义式的出现时间
+ 在真正需要用到的时候再定义，并且尽量使用非默认构造函数。
##　循环体内定义的两种情况
情况一：
```C++
// 定义在循环体外
Widget w;
for(int i=0; i<len;  ++i){
    w=something;
}
```
情况二：
```C++
// 定义在循环体内
for(int i=0; i<len; ++i){
    Widget w(something);
}
```
这两种情况哪种实现方式更快？
情况一的开销如下：一次构造、一次析构、n次赋值  
情况二的开销如下：n次构造、n次析构  
这就需要比对赋值与构造析构哪种更耗费时间,来选择最佳的情况。

# 条款27:尽可能减少强制类型转换动作
+ 尽量避免转型，特别是避免dynamic_casts.如果需要转型，试着写出无需转型的设计
+ 如果必须要用到转型，将转型封装在某个函数中，而不是直接调用转型。
+ 尝试使用C++风格的运算符转型

1. dynamic_cast用于派生类向基类转型
```C++
/*pl是low类指针*/
/*ph是high类指针*/
/*high是low的派生类*/
    pl = dynamic_cast<LOW*>(ph);
```
2. const_cast 运算符
可以改变const标签

3. static_cast
当类型与被转换类型可以被隐式转换时，该运算符才可生效

4. reinterpret_cast 运算符
